// use anyhow::{Error as AnyError, Ok, Result};
use std::ffi::OsStr;
use std::fs;
use std::path::{Path, PathBuf};
use std::string::ToString;
use substreams_ethereum::Abigen;

/// Default output directory for generated code.
pub const DEFAULT_OUTPUT_DIR: &str = "src";
pub const DEFAULT_PROTO_DIR: &str = "proto";

#[derive(thiserror::Error, Debug)]
pub enum Error {}

/// Get filenames without file type suffix
pub fn dir_filenames(path: impl AsRef<OsStr>) -> Vec<String> {
    println!("Searching for files in {}", path.as_ref().to_str().unwrap());
    if let Ok(read_dir) = fs::read_dir(&path.as_ref()) {
        read_dir
            .map(|x| {
                x.unwrap()
                    .path()
                    .file_stem()
                    .unwrap()
                    .to_str()
                    .unwrap()
                    .to_string()
            })
            .collect::<Vec<String>>()
    } else {
        Vec::new()
    }
}

fn write_or_replace_if_different(filepath: PathBuf, content: String) {
    if filepath.exists() {
        let mut current_content = fs::read_to_string(&filepath).unwrap();
        // This is primarily for windows OS to make sure different newline declarations are treated equivalent when comparing file contents
        current_content = current_content.replace("\r\n", "\n");
        if content == current_content {
            return;
        }
    }

    fs::write(filepath, content).unwrap();
}

pub fn generate_abi(out_dir: Option<&str>) -> Result<(), Error> {
    let out_dir = out_dir.unwrap_or(DEFAULT_OUTPUT_DIR);
    let mut abi_filenames = dir_filenames("./abi");
    abi_filenames.sort();
    let target_abi_dir = Path::new(out_dir).join("abi");
    fs::remove_dir_all(&target_abi_dir).ok();
    fs::create_dir_all(&target_abi_dir).ok();

    // generate abi structs under target/abi based on abi json under abi/
    abi_filenames.iter().for_each(|contract| {
        Abigen::new(contract, &format!("abi/{}.json", contract))
            .unwrap()
            .generate()
            .unwrap()
            .write_to_file(format!("{}/abi/{}.rs", out_dir, contract))
            .unwrap()
    });

    // generate src/abi.rs module
    write_or_replace_if_different(
        Path::new("src").join("abi").join("mod.rs"),
        format!(
            "// DO NOT EDIT - the file is generated by build script\n{}",
            abi_filenames
                .iter()
                .map(|contract| {
                    format!(
                        "#[rustfmt::skip]\n#[allow(unused_imports)]\n#[path = \"./{}.rs\"]\npub mod {};\n",
                        contract, contract
                    )
                })
                .collect::<Vec<_>>()
                .join("\n")
        ),
    );

    Ok(())
}

fn main() -> Result<(), Error> {
    println!("cargo:rerun-if-changed=abi");
    generate_abi(Some("src"))?;
    Ok(())
}
